package de.upb.sse.jess.stubbing.spoon.jdk;

import spoon.reflect.code.CtBlock;
import spoon.reflect.code.CtExpression;
import spoon.reflect.code.CtReturn;
import spoon.reflect.declaration.*;
import spoon.reflect.factory.Factory;
import spoon.reflect.reference.CtTypeReference;

import java.util.*;

/**
 * Generates minimal JDK stubs for common Java types that are needed for SootUp compatibility.
 * 
 * These stubs provide basic class/interface structures so that SootUp can build a complete
 * class hierarchy when analyzing Jess-generated bytecode.
 */
public class JdkStubGenerator {
    
    private final Factory factory;
    private final Set<String> generatedStubs = new HashSet<>();
    
    public JdkStubGenerator(Factory factory) {
        this.factory = factory;
    }
    
    /**
     * Generate JDK stubs for common types.
     * @return Number of stubs generated
     */
    public int generateJdkStubs() {
        int count = 0;
        
        // java.lang.* - Core types
        count += generateLangStubs();
        
        // java.util.* - Collections
        count += generateUtilStubs();
        
        // java.io.* - I/O types
        count += generateIoStubs();
        
        return count;
    }
    
    /**
     * Generate stubs for java.lang.* package.
     */
    private int generateLangStubs() {
        int count = 0;
        
        // Object - root of all classes
        if (generateClass("java.lang", "Object", null, 
                Arrays.asList("Cloneable", "java.io.Serializable"))) {
            count++;
        }
        
        // String - most commonly used
        if (generateClass("java.lang", "String", "Object",
                Arrays.asList("CharSequence", "Comparable<String>", "java.io.Serializable"))) {
            addStringMethods();
            count++;
        }
        
        // Wrapper types
        if (generateClass("java.lang", "Integer", "Number",
                Arrays.asList("Comparable<Integer>"))) {
            count++;
        }
        if (generateClass("java.lang", "Boolean", "Object",
                Arrays.asList("Comparable<Boolean>", "java.io.Serializable"))) {
            count++;
        }
        if (generateClass("java.lang", "Character", "Object",
                Arrays.asList("Comparable<Character>", "java.io.Serializable"))) {
            count++;
        }
        if (generateClass("java.lang", "Byte", "Number",
                Arrays.asList("Comparable<Byte>"))) {
            count++;
        }
        if (generateClass("java.lang", "Short", "Number",
                Arrays.asList("Comparable<Short>"))) {
            count++;
        }
        if (generateClass("java.lang", "Long", "Number",
                Arrays.asList("Comparable<Long>"))) {
            count++;
        }
        if (generateClass("java.lang", "Float", "Number",
                Arrays.asList("Comparable<Float>"))) {
            count++;
        }
        if (generateClass("java.lang", "Double", "Number",
                Arrays.asList("Comparable<Double>"))) {
            count++;
        }
        
        // Number - abstract base class
        if (generateAbstractClass("java.lang", "Number", "Object",
                Arrays.asList("java.io.Serializable"))) {
            count++;
        }
        
        // Void
        if (generateClass("java.lang", "Void", "Object", null)) {
            count++;
        }
        
        // Class
        if (generateClass("java.lang", "Class", "Object",
                Arrays.asList("java.io.Serializable"))) {
            count++;
        }
        
        // Enum
        if (generateAbstractClass("java.lang", "Enum", "Object",
                Arrays.asList("Comparable<E>", "java.io.Serializable"))) {
            count++;
        }
        
        // Exception hierarchy
        if (generateClass("java.lang", "Throwable", "Object",
                Arrays.asList("java.io.Serializable"))) {
            count++;
        }
        if (generateClass("java.lang", "Exception", "Throwable", null)) {
            count++;
        }
        if (generateClass("java.lang", "RuntimeException", "Exception", null)) {
            count++;
        }
        if (generateClass("java.lang", "Error", "Throwable", null)) {
            count++;
        }
        
        // Interfaces
        if (generateInterface("java.lang", "Cloneable", null)) {
            count++;
        }
        if (generateInterface("java.lang", "Comparable", "T")) {
            count++;
        }
        if (generateInterface("java.lang", "Iterable", "T")) {
            count++;
        }
        if (generateInterface("java.lang", "CharSequence", null)) {
            count++;
        }
        if (generateInterface("java.lang", "AutoCloseable", null)) {
            count++;
        }
        
        return count;
    }
    
    /**
     * Generate stubs for java.util.* package.
     */
    private int generateUtilStubs() {
        int count = 0;
        
        // Collection hierarchy
        if (generateInterface("java.util", "Collection", "E")) {
            count++;
        }
        if (generateInterface("java.util", "List", "E", "Collection<E>")) {
            count++;
        }
        if (generateInterface("java.util", "Set", "E", "Collection<E>")) {
            count++;
        }
        if (generateInterface("java.util", "Map", "K,V")) {
            count++;
        }
        
        // Implementations
        if (generateClass("java.util", "ArrayList", "AbstractList",
                Arrays.asList("List<E>", "RandomAccess", "Cloneable", "java.io.Serializable"))) {
            count++;
        }
        if (generateClass("java.util", "HashSet", "AbstractSet",
                Arrays.asList("Set<E>", "Cloneable", "java.io.Serializable"))) {
            count++;
        }
        if (generateClass("java.util", "HashMap", "AbstractMap",
                Arrays.asList("Map<K,V>", "Cloneable", "java.io.Serializable"))) {
            count++;
        }
        
        // Abstract classes
        if (generateAbstractClass("java.util", "AbstractCollection", "Object",
                Arrays.asList("Collection<E>"))) {
            count++;
        }
        if (generateAbstractClass("java.util", "AbstractList", "AbstractCollection<E>",
                Arrays.asList("List<E>"))) {
            count++;
        }
        if (generateAbstractClass("java.util", "AbstractSet", "AbstractCollection<E>",
                Arrays.asList("Set<E>"))) {
            count++;
        }
        if (generateAbstractClass("java.util", "AbstractMap", "Object",
                Arrays.asList("Map<K,V>"))) {
            count++;
        }
        
        // Iterator
        if (generateInterface("java.util", "Iterator", "E")) {
            count++;
        }
        
        // Optional
        if (generateClass("java.util", "Optional", "Object",
                Arrays.asList("java.io.Serializable"))) {
            count++;
        }
        
        // Objects utility
        if (generateClass("java.util", "Objects", "Object", null)) {
            count++;
        }
        
        // RandomAccess marker interface
        if (generateInterface("java.util", "RandomAccess", null)) {
            count++;
        }
        
        return count;
    }
    
    /**
     * Generate stubs for java.io.* package.
     */
    private int generateIoStubs() {
        int count = 0;
        
        // Serializable marker interface
        if (generateInterface("java.io", "Serializable", null)) {
            count++;
        }
        
        // Closeable
        if (generateInterface("java.io", "Closeable", null, "AutoCloseable")) {
            count++;
        }
        
        // Flushable
        if (generateInterface("java.io", "Flushable", null)) {
            count++;
        }
        
        // File
        if (generateClass("java.io", "File", "Object",
                Arrays.asList("Comparable<File>", "java.io.Serializable"))) {
            count++;
        }
        
        // Streams
        if (generateAbstractClass("java.io", "InputStream", "Object",
                Arrays.asList("Closeable"))) {
            count++;
        }
        if (generateAbstractClass("java.io", "OutputStream", "Object",
                Arrays.asList("Closeable", "Flushable"))) {
            count++;
        }
        if (generateAbstractClass("java.io", "Reader", "Object",
                Arrays.asList("Readable", "Closeable"))) {
            count++;
        }
        if (generateAbstractClass("java.io", "Writer", "Object",
                Arrays.asList("Appendable", "Closeable", "Flushable"))) {
            count++;
        }
        
        // Readable interface
        if (generateInterface("java.io", "Readable", null)) {
            count++;
        }
        
        // Appendable interface
        if (generateInterface("java.io", "Appendable", null)) {
            count++;
        }
        
        return count;
    }
    
    /**
     * Generate a class stub.
     */
    private boolean generateClass(String packageName, String className, String superClass,
                                  List<String> interfaces) {
        String fqn = packageName + "." + className;
        if (generatedStubs.contains(fqn)) {
            return false; // Already generated
        }
        
        try {
            // Check if type already exists in the model (from classpath or already generated)
            CtType<?> existingType = factory.Type().get(fqn);
            if (existingType != null) {
                // Type already exists - don't generate stub
                generatedStubs.add(fqn);
                return false;
            }
            
            // Try to resolve the type - if it's resolvable from classpath, don't generate stub
            try {
                CtTypeReference<?> typeRef = factory.Type().createReference(fqn);
                CtType<?> resolvedType = typeRef.getTypeDeclaration();
                if (resolvedType != null && !resolvedType.isShadow()) {
                    // Type is resolvable from classpath - don't generate stub
                    generatedStubs.add(fqn);
                    return false;
                }
            } catch (Exception e) {
                // Type is not resolvable - safe to generate stub
            }
            
            CtPackage pkg = factory.Package().getOrCreate(packageName);
            
            CtClass<?> cls = factory.Class().create(pkg, className);
            cls.addModifier(ModifierKind.PUBLIC);
            
            // Set superclass
            if (superClass != null) {
                CtTypeReference<?> superRef = factory.Type().createReference(superClass);
                cls.setSuperclass(superRef);
            }
            
            // Add interfaces
            if (interfaces != null) {
                for (String iface : interfaces) {
                    CtTypeReference<?> ifaceRef = factory.Type().createReference(iface);
                    cls.addSuperInterface(ifaceRef);
                }
            }
            
            // Add default constructor
            CtConstructor<?> ctor = factory.Constructor().create(cls, 
                    Set.of(ModifierKind.PUBLIC), Collections.emptyList(), Collections.emptySet());
            ctor.setBody(factory.Core().createBlock());
            
            generatedStubs.add(fqn);
            return true;
        } catch (Exception e) {
            System.err.println("Failed to generate JDK stub for " + fqn + ": " + e.getMessage());
            return false;
        }
    }
    
    /**
     * Generate an abstract class stub.
     */
    private boolean generateAbstractClass(String packageName, String className, String superClass,
                                         List<String> interfaces) {
        boolean result = generateClass(packageName, className, superClass, interfaces);
        if (result) {
            String fqn = packageName + "." + className;
            CtType<?> type = factory.Type().get(fqn);
            if (type instanceof CtClass) {
                ((CtClass<?>) type).addModifier(ModifierKind.ABSTRACT);
            }
        }
        return result;
    }
    
    /**
     * Generate an interface stub.
     */
    private boolean generateInterface(String packageName, String interfaceName, String typeParams) {
        return generateInterface(packageName, interfaceName, typeParams, null);
    }
    
    /**
     * Generate an interface stub with super interfaces.
     */
    private boolean generateInterface(String packageName, String interfaceName, String typeParams,
                                      String superInterface) {
        String fqn = packageName + "." + interfaceName;
        if (generatedStubs.contains(fqn)) {
            return false; // Already generated
        }
        
        try {
            // Check if type already exists in the model (from classpath or already generated)
            CtType<?> existingType = factory.Type().get(fqn);
            if (existingType != null) {
                // Type already exists - don't generate stub
                generatedStubs.add(fqn);
                return false;
            }
            
            // Try to resolve the type - if it's resolvable from classpath, don't generate stub
            try {
                CtTypeReference<?> typeRef = factory.Type().createReference(fqn);
                CtType<?> resolvedType = typeRef.getTypeDeclaration();
                if (resolvedType != null && !resolvedType.isShadow()) {
                    // Type is resolvable from classpath - don't generate stub
                    generatedStubs.add(fqn);
                    return false;
                }
            } catch (Exception e) {
                // Type is not resolvable - safe to generate stub
            }
            
            CtPackage pkg = factory.Package().getOrCreate(packageName);
            
            CtInterface<?> iface = factory.Interface().create(pkg, interfaceName);
            iface.addModifier(ModifierKind.PUBLIC);
            
            // Add type parameters if specified
            if (typeParams != null && !typeParams.isEmpty()) {
                String[] params = typeParams.split(",");
                for (String param : params) {
                    param = param.trim();
                    CtTypeParameter typeParam = factory.Core().createTypeParameter();
                    typeParam.setSimpleName(param);
                    iface.addFormalCtTypeParameter(typeParam);
                }
            }
            
            // Add super interface
            if (superInterface != null) {
                CtTypeReference<?> superRef = factory.Type().createReference(superInterface);
                iface.addSuperInterface(superRef);
            }
            
            generatedStubs.add(fqn);
            return true;
        } catch (Exception e) {
            System.err.println("Failed to generate JDK interface stub for " + fqn + ": " + e.getMessage());
            return false;
        }
    }
    
    /**
     * Add essential methods to String class.
     */
    private void addStringMethods() {
        try {
            CtClass<?> stringClass = factory.Class().get("java.lang.String");
            if (stringClass == null) return;
            
            // length()
            addMethod(stringClass, "length", factory.Type().INTEGER_PRIMITIVE, Collections.emptyList());
            
            // charAt(int)
            addMethod(stringClass, "charAt", factory.Type().CHARACTER_PRIMITIVE,
                    Arrays.asList(factory.Type().INTEGER_PRIMITIVE));
            
            // compareTo(String)
            addMethod(stringClass, "compareTo", factory.Type().INTEGER_PRIMITIVE,
                    Arrays.asList(factory.Type().createReference("java.lang.String")));
            
            // equals(Object)
            addMethod(stringClass, "equals", factory.Type().BOOLEAN_PRIMITIVE,
                    Arrays.asList(factory.Type().createReference("java.lang.Object")));
            
            // hashCode()
            addMethod(stringClass, "hashCode", factory.Type().INTEGER_PRIMITIVE, Collections.emptyList());
            
            // toString()
            addMethod(stringClass, "toString", factory.Type().createReference("java.lang.String"),
                    Collections.emptyList());
        } catch (Exception e) {
            // Ignore - methods might already exist or can't be added
        }
    }
    
    /**
     * Add a method to a class.
     */
    private void addMethod(CtClass<?> cls, String methodName, CtTypeReference<?> returnType,
                           List<CtTypeReference<?>> paramTypes) {
        try {
            // Check if method already exists
            if (cls.getMethod(methodName) != null) {
                return;
            }
            
            // Create parameters
            List<CtParameter<?>> params = new ArrayList<>();
            for (int i = 0; i < paramTypes.size(); i++) {
                CtParameter<?> param = factory.Core().createParameter();
                param.setType(paramTypes.get(i));
                param.setSimpleName("arg" + i);
                params.add(param);
            }
            
            // Create method
            CtMethod<?> method = factory.Method().create(cls,
                    Set.of(ModifierKind.PUBLIC),
                    returnType,
                    methodName,
                    params,
                    Collections.emptySet());
            
            // Add body with default return
            CtBlock<?> body = factory.Core().createBlock();
            if (!returnType.equals(factory.Type().VOID_PRIMITIVE)) {
                CtReturn<?> ret = factory.Core().createReturn();
                Object defaultValue = getDefaultValue(returnType);
                @SuppressWarnings({"unchecked", "rawtypes"})
                CtExpression literal = (CtExpression) factory.Code().createLiteral(defaultValue != null ? defaultValue : null);
                ret.setReturnedExpression(literal);
                body.addStatement(ret);
            }
            method.setBody(body);
        } catch (Exception e) {
            // Ignore method creation failures
        }
    }
    
    /**
     * Get default value for a type.
     */
    private Object getDefaultValue(CtTypeReference<?> type) {
        if (type.isPrimitive()) {
            String typeName = type.getSimpleName();
            switch (typeName) {
                case "boolean": return false;
                case "byte": return (byte) 0;
                case "char": return '\0';
                case "short": return (short) 0;
                case "int": return 0;
                case "long": return 0L;
                case "float": return 0.0f;
                case "double": return 0.0;
                default: return null;
            }
        }
        return null;
    }
    
    /**
     * Get boxed type for a primitive.
     */
    private CtTypeReference<?> getBoxedType(CtTypeReference<?> type) {
        if (!type.isPrimitive()) {
            return type;
        }
        String typeName = type.getSimpleName();
        switch (typeName) {
            case "boolean": return factory.Type().createReference("java.lang.Boolean");
            case "byte": return factory.Type().createReference("java.lang.Byte");
            case "char": return factory.Type().createReference("java.lang.Character");
            case "short": return factory.Type().createReference("java.lang.Short");
            case "int": return factory.Type().createReference("java.lang.Integer");
            case "long": return factory.Type().createReference("java.lang.Long");
            case "float": return factory.Type().createReference("java.lang.Float");
            case "double": return factory.Type().createReference("java.lang.Double");
            default: return type;
        }
    }
}

